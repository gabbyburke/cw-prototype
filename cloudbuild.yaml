steps:
  # Conditionally build and push Docker images
  - name: 'gcr.io/cloud-builders/docker'
    id: 'Build and Push Images'
    entrypoint: 'bash'
    args:
      - -c
      - |
        set -e
        echo "Starting Docker image build process..."
        echo "BUILD_IMAGES: ${_BUILD_IMAGES}"
        
        # Function to build and push image
        build_and_push_image() {
          local folder_path="$1"
          local resource_name="$2"
          
          echo "Building image for $resource_name from $folder_path"
          
          # Create image name following naming convention
          local image_name="${_DOCKER_REPO_PATH}/${_PROJECT_BASE_NAME}${_UNIQUE_ID}-${_ENV}-${resource_name}-dimg"
          
          # Build and tag with both BUILD_ID and latest
          docker build -t "${image_name}:${BUILD_ID}" -t "${image_name}:latest" "$folder_path"
          
          # Push both tags
          docker push "${image_name}:${BUILD_ID}"
          docker push "${image_name}:latest"
          
          echo "Successfully built and pushed $image_name"
        }
        
        # Build images for known services
        declare -a services=("core-case-mgmt" "referral-intake" "ui")
        declare -a build_pids=()
        
        for service in "${services[@]}"; do
          # Convert service name to directory path
          service_dir=$(echo "$service" | tr '-' '_')
          
          # Determine the correct path
          if [[ "$service" == "ui" ]]; then
            dir_path="src/ui"
          else
            dir_path="src/apis/$service_dir"
          fi
          
          # Check if Dockerfile exists and if we should build this image
          if [[ -f "$dir_path/Dockerfile" ]] && ([[ "${_BUILD_IMAGES}" == "all" ]] || [[ "${_BUILD_IMAGES}" == *"$service"* ]]); then
            echo "Building image for $service from $dir_path..."
            build_and_push_image "$dir_path" "$service" &
            build_pids+=($!)
          else
            echo "Skipping $service (Dockerfile not found or not in BUILD_IMAGES list)"
          fi
        done
        
        # Wait for all background builds to complete
        for pid in "${build_pids[@]}"; do
          wait "$pid"
        done
        echo "All Docker builds completed"

  # Terraform Init
  - name: 'hashicorp/terraform:latest'
    id: 'Terraform Init'
    args: ['init']
    dir: 'envs/${_ENV}'

  # Terraform Plan
  - name: 'hashicorp/terraform:latest'
    id: 'Terraform Plan'
    args:
      - 'plan'
      - '-out=tfplan'
      - '-var=project_id=${_PROJECT_ID}'
      - '-var=region=${_REGION}'
      - '-var=location=${_LOCATION}'
      - '-var=env=${_ENV}'
      - '-var=project_base_name=${_PROJECT_BASE_NAME}'
      - '-var=unique_id=${_UNIQUE_ID}'
      - '-var=docker_repo_path=${_DOCKER_REPO_PATH}'
    dir: 'envs/${_ENV}'

  # Terraform Apply
  - name: 'hashicorp/terraform:latest'
    id: 'Terraform Apply'
    args: ['apply', '-auto-approve', 'tfplan']
    dir: 'envs/${_ENV}'

  # Deploy new Cloud Run revisions to ensure they use the latest images
  - name: 'gcr.io/google.com/cloudsdktool/cloud-sdk'
    id: 'Deploy New Cloud Run Revisions'
    entrypoint: 'bash'
    args:
      - -c
      - |
        set -e
        echo "Starting Cloud Run revision deployment..."
        echo "BUILD_IMAGES: ${_BUILD_IMAGES}"
        
        # Function to deploy new revision
        deploy_revision() {
          local resource_name="$1"
          local service_name="${_PROJECT_BASE_NAME}${_UNIQUE_ID}-${_ENV}-${resource_name}-crsvc"
          local image_name="${_PROJECT_BASE_NAME}${_UNIQUE_ID}-${_ENV}-${resource_name}-dimg:${BUILD_ID}"
          
          echo "Deploying new revision for service: $service_name"
          echo "Using image: $image_name"
          
          # Execute the deployment with conditional IAP flag
          if [[ "$resource_name" == "ui" ]]; then
            echo "Deploying UI service with IAP enabled"
            gcloud beta run deploy "$service_name" \
              --image="${_DOCKER_REPO_PATH}/$image_name" \
              --region="${_REGION}" \
              --project="${_PROJECT_ID}" \
              --iap \
              --quiet
          else
            echo "Deploying API service"
            gcloud beta run deploy "$service_name" \
              --image="${_DOCKER_REPO_PATH}/$image_name" \
              --region="${_REGION}" \
              --project="${_PROJECT_ID}" \
              --quiet
          fi
          echo "Successfully deployed $service_name"
        }
        
        # Deploy revisions for known services that were built
        declare -a services=("core-case-mgmt" "referral-intake" "ui")
        
        for service in "${services[@]}"; do
          # Check if we built this image
          if [[ "${_BUILD_IMAGES}" == "all" ]] || [[ "${_BUILD_IMAGES}" == *"$service"* ]]; then
            echo "Deploying new revision for $service..."
            deploy_revision "$service"
          else
            echo "Skipping deployment for $service (image not built)"
          fi
        done
        
        echo "All Cloud Run deployments completed"

substitutions:
  _PROJECT_ID: "${PROJECT_ID}" # ${PROJECT_ID} is a built-in variable
  _REGION: "us-central1" # default value
  _LOCATION: "us" # default value
  _ENV: "DEV" # default value
  _PROJECT_BASE_NAME: "ccwis" # default value
  _UNIQUE_ID: "" # will be provided by setup script
  _DOCKER_REPO_PATH: "" # will be provided by setup script
  _BUILD_IMAGES: "all" # default value - builds everything

serviceAccount: 'projects/${_PROJECT_ID}/serviceAccounts/${_PROJECT_BASE_NAME}${_UNIQUE_ID}-cloudbuild-sa@${_PROJECT_ID}.iam.gserviceaccount.com'

options:
  automapSubstitutions: true
  dynamic_substitutions: true
  logging: CLOUD_LOGGING_ONLY
