steps:
  # Conditionally build and push Docker images
  - name: 'gcr.io/cloud-builders/docker'
    id: 'Build and Push Images'
    entrypoint: 'bash'
    args:
      - -c
      - |
        set -e
        echo "Starting Docker image build process..."
        echo "BUILD_IMAGES: ${_BUILD_IMAGES}"
        
        # Function to build and push image
        build_and_push_image() {
          local folder_path="$1"
          local resource_name="$2"
          
          echo "Building image for $resource_name from $folder_path"
          
          # Create image name following naming convention
          local image_name="${_DOCKER_REPO_PATH}/${_PROJECT_BASE_NAME}${_UNIQUE_ID}-${_ENV}-${resource_name}-dimg"
          
          # Build and tag with both BUILD_ID and latest
          docker build -t "${image_name}:${BUILD_ID}" -t "${image_name}:latest" "$folder_path"
          
          # Push both tags
          docker push "${image_name}:${BUILD_ID}"
          docker push "${image_name}:latest"
          
          echo "Successfully built and pushed $image_name"
        }
        
        # Find all directories with Dockerfiles and build them
        find src -name "Dockerfile" -type f | while read dockerfile; do
          # Get the directory containing the Dockerfile
          dir_path=$(dirname "$dockerfile")
          
          # Extract the folder name and convert underscores to dashes
          folder_name=$(basename "$dir_path")
          resource_name=$(echo "$folder_name" | tr '_' '-')
          
          echo "Found Dockerfile in: $dir_path"
          echo "Resource name: $resource_name"
          
          # Check if we should build this image
          if [[ "${_BUILD_IMAGES}" == "all" ]] || [[ "${_BUILD_IMAGES}" == *"$resource_name"* ]]; then
            echo "Building image for $resource_name..."
            build_and_push_image "$dir_path" "$resource_name" &
          else
            echo "Skipping $resource_name (not in BUILD_IMAGES list)"
          fi
        done
        
        # Wait for all background builds to complete
        wait
        echo "All Docker builds completed"

  # Terraform Init
  - name: 'hashicorp/terraform:latest'
    id: 'Terraform Init'
    args: ['init']
    dir: 'envs/${_ENV}'

  # Terraform Plan
  - name: 'hashicorp/terraform:latest'
    id: 'Terraform Plan'
    args:
      - 'plan'
      - '-out=tfplan'
      - '-var=project_id=${_PROJECT_ID}'
      - '-var=region=${_REGION}'
      - '-var=location=${_LOCATION}'
      - '-var=env=${_ENV}'
      - '-var=project_base_name=${_PROJECT_BASE_NAME}'
      - '-var=unique_id=${_UNIQUE_ID}'
      - '-var=docker_repo_path=${_DOCKER_REPO_PATH}'
    dir: 'envs/${_ENV}'

  # Terraform Apply
  - name: 'hashicorp/terraform:latest'
    id: 'Terraform Apply'
    args: ['apply', '-auto-approve', 'tfplan']
    dir: 'envs/${_ENV}'

  # Deploy new Cloud Run revisions to ensure they use the latest images
  - name: 'gcr.io/google.com/cloudsdktool/cloud-sdk'
    id: 'Deploy New Cloud Run Revisions'
    entrypoint: 'bash'
    args:
      - -c
      - |
        set -e
        echo "Starting Cloud Run revision deployment..."
        echo "BUILD_IMAGES: ${_BUILD_IMAGES}"
        
        # Function to deploy new revision
        deploy_revision() {
          local resource_name="$1"
          local service_name="${_PROJECT_BASE_NAME}${_UNIQUE_ID}-${_ENV}-${resource_name}-crsvc"
          local image_name="${_PROJECT_BASE_NAME}${_UNIQUE_ID}-${_ENV}-${resource_name}-dimg:${BUILD_ID}"
          
          echo "Deploying new revision for service: $service_name"
          echo "Using image: $image_name"
          
          # Base deploy command
          local deploy_cmd="gcloud beta run deploy $service_name --image=${_DOCKER_REPO_PATH}/$image_name --region=${_REGION} --project=${_PROJECT_ID} --quiet"
          
          # Add IAP flag for UI service
          if [[ "$resource_name" == "ui" ]]; then
            deploy_cmd="$deploy_cmd --iap"
            echo "Adding --iap flag for UI service"
          fi
          
          # Execute the deployment
          eval "$deploy_cmd"
          echo "Successfully deployed $service_name"
        }
        
        # Find all directories with Dockerfiles and deploy new revisions for built images
        find src -name "Dockerfile" -type f | while read dockerfile; do
          # Get the directory containing the Dockerfile
          dir_path=$(dirname "$dockerfile")
          
          # Extract the folder name and convert underscores to dashes
          folder_name=$(basename "$dir_path")
          resource_name=$(echo "$folder_name" | tr '_' '-')
          
          # Check if we built this image
          if [[ "${_BUILD_IMAGES}" == "all" ]] || [[ "${_BUILD_IMAGES}" == *"$resource_name"* ]]; then
            echo "Deploying new revision for $resource_name..."
            deploy_revision "$resource_name"
          else
            echo "Skipping deployment for $resource_name (image not built)"
          fi
        done
        
        echo "All Cloud Run deployments completed"

substitutions:
  _PROJECT_ID: "${PROJECT_ID}" # ${PROJECT_ID} is a built-in variable
  _REGION: "us-central1" # default value
  _LOCATION: "us" # default value
  _ENV: "DEV" # default value
  _PROJECT_BASE_NAME: "ccwis" # default value
  _UNIQUE_ID: "" # will be provided by setup script
  _DOCKER_REPO_PATH: "" # will be provided by setup script
  _BUILD_IMAGES: "all" # default value - builds everything

serviceAccount: 'projects/${_PROJECT_ID}/serviceAccounts/${_PROJECT_BASE_NAME}${_UNIQUE_ID}-cloudbuild-sa@${_PROJECT_ID}.iam.gserviceaccount.com'

options:
  automapSubstitutions: true
  dynamic_substitutions: true
  logging: CLOUD_LOGGING_ONLY
